#!/usr/bin/env python3
"""
Trading Bot Debugger
Identifies why trades aren't firing in your bots
"""

import os
import time
import pandas as pd
import numpy as np
from datetime import datetime, timezone
from pybit.unified_trading import HTTP
from dotenv import load_dotenv

load_dotenv()

class TradingBotDebugger:
    def __init__(self, symbol, demo_mode=True):
        self.symbol = symbol
        self.demo_mode = demo_mode
        self.errors = []
        self.warnings = []
        self.info = []
        
        # Get credentials
        prefix = 'TESTNET_' if demo_mode else 'LIVE_'
        self.api_key = os.getenv(f'{prefix}BYBIT_API_KEY')
        self.api_secret = os.getenv(f'{prefix}BYBIT_API_SECRET')
        self.exchange = None
        
    def run_all_checks(self):
        """Run all debugging checks"""
        print(f"\n{'='*60}")
        print(f"TRADING BOT DEBUGGER - {self.symbol}")
        print(f"Mode: {'TESTNET' if self.demo_mode else 'LIVE'}")
        print(f"Time: {datetime.now(timezone.utc).isoformat()}")
        print(f"{'='*60}\n")
        
        # 1. Check credentials
        print("1. CHECKING API CREDENTIALS...")
        if self.check_credentials():
            print("   âœ… Credentials found\n")
        else:
            print("   âŒ CRITICAL: No credentials\n")
            return False
            
        # 2. Test connection
        print("2. TESTING CONNECTION...")
        if self.test_connection():
            print("   âœ… Connected to exchange\n")
        else:
            print("   âŒ CRITICAL: Cannot connect\n")
            return False
            
        # 3. Test authentication
        print("3. TESTING AUTHENTICATION...")
        if self.test_authentication():
            print("   âœ… Authentication successful\n")
        else:
            print("   âŒ CRITICAL: Authentication failed\n")
            return False
            
        # 4. Check account balance
        print("4. CHECKING ACCOUNT BALANCE...")
        balance = self.check_balance()
        if balance:
            print(f"   âœ… Balance: ${balance:.2f}\n")
        else:
            print("   âš ï¸  WARNING: No balance or cannot fetch\n")
            
        # 5. Check market data
        print("5. CHECKING MARKET DATA...")
        market_data = self.check_market_data()
        if market_data:
            print(f"   âœ… Current price: ${market_data['price']:.5f}\n")
        else:
            print("   âŒ CRITICAL: Cannot fetch market data\n")
            return False
            
        # 6. Check existing positions
        print("6. CHECKING EXISTING POSITIONS...")
        position = self.check_positions()
        if position:
            print(f"   âš ï¸  Position exists: {position['side']} {position['size']} @ ${position['price']:.5f}")
            print("   ðŸ“Œ Bot won't open new trades with existing position\n")
        else:
            print("   âœ… No positions (ready to trade)\n")
            
        # 7. Check open orders
        print("7. CHECKING OPEN ORDERS...")
        orders = self.check_open_orders()
        if orders:
            print(f"   âš ï¸  {len(orders)} open orders found")
            print("   ðŸ“Œ May prevent new trades\n")
        else:
            print("   âœ… No open orders\n")
            
        # 8. Test signal generation
        print("8. TESTING SIGNAL GENERATION...")
        signal = self.test_signal_generation()
        if signal:
            print(f"   âœ… Signal generated: {signal}\n")
        else:
            print("   âš ï¸  No signal (normal - waiting for conditions)\n")
            
        # 9. Test order placement
        print("9. TESTING ORDER PLACEMENT (dry run)...")
        if self.test_order_placement():
            print("   âœ… Order validation passed\n")
        else:
            print("   âŒ Order would fail\n")
            
        # 10. Check instrument info
        print("10. CHECKING INSTRUMENT SPECIFICATIONS...")
        inst_info = self.check_instrument_info()
        if inst_info:
            print(f"   âœ… Min qty: {inst_info['min_qty']}")
            print(f"   âœ… Qty step: {inst_info['qty_step']}")
            print(f"   âœ… Min notional: ${inst_info['min_notional']}\n")
        else:
            print("   âš ï¸  Cannot fetch instrument info\n")
            
        # Summary
        self.print_summary()
        return True
        
    def check_credentials(self):
        """Check if API credentials exist"""
        if not self.api_key or not self.api_secret:
            self.errors.append("Missing API credentials in .env file")
            prefix = 'TESTNET_' if self.demo_mode else 'LIVE_'
            print(f"   Required: {prefix}BYBIT_API_KEY")
            print(f"   Required: {prefix}BYBIT_API_SECRET")
            return False
        return True
        
    def test_connection(self):
        """Test basic connection to exchange"""
        try:
            self.exchange = HTTP(
                demo=self.demo_mode,
                api_key=self.api_key,
                api_secret=self.api_secret
            )
            
            result = self.exchange.get_server_time()
            if result.get('retCode') != 0:
                self.errors.append(f"Server error: {result.get('retMsg')}")
                return False
            return True
        except Exception as e:
            self.errors.append(f"Connection error: {str(e)}")
            return False
            
    def test_authentication(self):
        """Test API authentication"""
        try:
            wallet = self.exchange.get_wallet_balance(accountType="UNIFIED")
            
            if wallet.get('retCode') == 0:
                return True
            elif wallet.get('retCode') == 401:
                self.errors.append("API authentication failed - check keys")
                print("   1. Verify API keys match environment (testnet/live)")
                print("   2. Check API permissions: Contract Trade enabled")
                print("   3. Ensure IP whitelist if configured")
                return False
            else:
                self.errors.append(f"Auth error: {wallet.get('retMsg')}")
                return False
        except Exception as e:
            self.errors.append(f"Auth exception: {str(e)}")
            return False
            
    def check_balance(self):
        """Check account balance"""
        try:
            wallet = self.exchange.get_wallet_balance(accountType="UNIFIED")
            if wallet.get('retCode') == 0:
                coins = wallet['result']['list'][0].get('coin', [])
                for coin in coins:
                    if coin['coin'] == 'USDT':
                        return float(coin.get('availableToWithdraw', 0))
            return 0
        except Exception as e:
            self.warnings.append(f"Cannot fetch balance: {str(e)}")
            return 0
            
    def check_market_data(self):
        """Check if market data is accessible"""
        try:
            kline = self.exchange.get_kline(
                category="linear",
                symbol=self.symbol,
                interval="5",
                limit=1
            )
            
            if kline.get('retCode') == 0 and kline['result']['list']:
                candle = kline['result']['list'][0]
                return {
                    'price': float(candle[4]),  # close price
                    'volume': float(candle[5])
                }
            return None
        except Exception as e:
            self.errors.append(f"Market data error: {str(e)}")
            return None
            
    def check_positions(self):
        """Check for existing positions"""
        try:
            pos = self.exchange.get_positions(
                category="linear",
                symbol=self.symbol
            )
            
            if pos.get('retCode') == 0 and pos['result']['list']:
                position = pos['result']['list'][0]
                if float(position.get('size', 0)) > 0:
                    return {
                        'side': position.get('side'),
                        'size': position.get('size'),
                        'price': float(position.get('avgPrice', 0))
                    }
            return None
        except Exception as e:
            self.warnings.append(f"Position check error: {str(e)}")
            return None
            
    def check_open_orders(self):
        """Check for open orders"""
        try:
            orders = self.exchange.get_open_orders(
                category="linear",
                symbol=self.symbol
            )
            
            if orders.get('retCode') == 0:
                return orders['result']['list']
            return []
        except Exception as e:
            self.warnings.append(f"Order check error: {str(e)}")
            return []
            
    def test_signal_generation(self):
        """Test if signals can be generated"""
        try:
            # Get recent klines for indicator calculation
            kline = self.exchange.get_kline(
                category="linear",
                symbol=self.symbol,
                interval="5",
                limit=100
            )
            
            if kline.get('retCode') != 0:
                return None
                
            df = pd.DataFrame(kline['result']['list'], 
                            columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'turnover'])
            df = df.astype(float)
            
            # Calculate simple indicators
            df['ema_20'] = df['close'].ewm(span=20, adjust=False).mean()
            df['ema_50'] = df['close'].ewm(span=50, adjust=False).mean()
            
            # RSI
            delta = df['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            df['rsi'] = 100 - (100 / (1 + rs))
            
            current_price = df['close'].iloc[-1]
            ema_20 = df['ema_20'].iloc[-1]
            ema_50 = df['ema_50'].iloc[-1]
            rsi = df['rsi'].iloc[-1]
            
            self.info.append(f"Price: {current_price:.5f}, EMA20: {ema_20:.5f}, EMA50: {ema_50:.5f}, RSI: {rsi:.1f}")
            
            # Check for basic signals
            if ema_20 > ema_50 and rsi < 30:
                return "BUY (EMA bullish + RSI oversold)"
            elif ema_20 < ema_50 and rsi > 70:
                return "SELL (EMA bearish + RSI overbought)"
                
            return None
        except Exception as e:
            self.warnings.append(f"Signal generation error: {str(e)}")
            return None
            
    def test_order_placement(self):
        """Test if orders can be placed (validation only)"""
        try:
            # Get current price
            ticker = self.exchange.get_tickers(
                category="linear",
                symbol=self.symbol
            )
            
            if ticker.get('retCode') != 0:
                return False
                
            current_price = float(ticker['result']['list'][0]['lastPrice'])
            
            # Calculate test order parameters
            test_qty = 10 / current_price  # $10 worth
            test_qty = round(test_qty, 3)  # Round to 3 decimals
            
            # Check minimum requirements
            if test_qty * current_price < 5:  # Min notional check
                self.warnings.append(f"Order too small: ${test_qty * current_price:.2f} < $5 minimum")
                
            self.info.append(f"Test order: {test_qty} @ ${current_price:.5f} = ${test_qty * current_price:.2f}")
            return True
            
        except Exception as e:
            self.errors.append(f"Order test error: {str(e)}")
            return False
            
    def check_instrument_info(self):
        """Check instrument specifications"""
        try:
            inst = self.exchange.get_instruments_info(
                category="linear",
                symbol=self.symbol
            )
            
            if inst.get('retCode') == 0 and inst['result']['list']:
                info = inst['result']['list'][0]
                return {
                    'min_qty': float(info['lotSizeFilter']['minOrderQty']),
                    'qty_step': float(info['lotSizeFilter']['qtyStep']),
                    'min_notional': float(info['lotSizeFilter'].get('minNotionalValue', 5))
                }
            return None
        except Exception as e:
            self.warnings.append(f"Instrument info error: {str(e)}")
            return None
            
    def print_summary(self):
        """Print debugging summary"""
        print(f"\n{'='*60}")
        print("DEBUGGING SUMMARY")
        print(f"{'='*60}\n")
        
        if self.errors:
            print("âŒ CRITICAL ERRORS (must fix):")
            for error in self.errors:
                print(f"   â€¢ {error}")
            print()
            
        if self.warnings:
            print("âš ï¸  WARNINGS (may affect trading):")
            for warning in self.warnings:
                print(f"   â€¢ {warning}")
            print()
            
        if self.info:
            print("â„¹ï¸  INFORMATION:")
            for info in self.info:
                print(f"   â€¢ {info}")
            print()
            
        if not self.errors:
            print("âœ… NO CRITICAL ERRORS FOUND")
            print("\nPossible reasons trades aren't firing:")
            print("1. Market conditions don't meet signal criteria")
            print("2. Position already exists (check position management)")
            print("3. Risk management preventing trades")
            print("4. Cooldown period between trades")
            print("5. Insufficient balance for minimum order size")
            print("\nRecommendations:")
            print("â€¢ Monitor bot logs for signal generation")
            print("â€¢ Check if indicators are reaching trigger levels")
            print("â€¢ Verify risk parameters allow trading")
            print("â€¢ Test with lower timeframes for more signals")
        else:
            print("ðŸ”§ FIX CRITICAL ERRORS FIRST!")


def main():
    """Run debugger for both bots"""
    
    # Debug bot 1
    print("\n" + "="*60)
    print("DEBUGGING: 5_FEES_MACD_VWAP_XRPUSDT.py")
    print("="*60)
    debugger1 = TradingBotDebugger('XRPUSDT', demo_mode=True)
    debugger1.run_all_checks()
    
    # Debug bot 2
    print("\n" + "="*60)
    print("DEBUGGING: 12_FEES_ML_GRID_SUIUSDT.py")
    print("="*60)
    debugger2 = TradingBotDebugger('SUIUSDT', demo_mode=True)
    debugger2.run_all_checks()
    
    print("\n" + "="*60)
    print("DEBUGGING COMPLETE")
    print("="*60)


if __name__ == "__main__":
    main()